package clonego

import (
	"bytes"
	"container/list"
	"fmt"
	"go/format"
	"path/filepath"
	"strings"

	"github.com/liwnn/prototool/parser"
)

const (
	cloneLineArray = "%v: Clone%vArray(m.Get%v()),"
	structClone    = `func (m *%v) Clone() *%v {
	if m == nil {
		return nil
	}
	return &%v{
		%v
	}
}
`
	baseArrayClone = `func Clone%vArray(p []%v) []%v {
	if p == nil {
		return nil
	}
	a := make([]%v, len(p), cap(p))
	copy(a, p)
	return a
}
`
	structArrayClone = `func Clone%vArray(p []*%v) []*%v {
	if p == nil {
		return nil
	}
	a := make([]*%v, len(p), cap(p))
	for i, v := range p {
		a[i] = v.Clone()
	}
	return a
}
`
	basePointerClone = `func Clone%vPointer(m *%v) *%v {
	if m == nil {
		return nil
	}
	p := new(%v)
	*p = *m
	return p
}
`
	cloneMap = `func Clone%vMap(p %v) %v {
	if p == nil {
		return nil
	}
	m := make(%v, len(p))
	for k, v := range p {
		m[k] = v%v
	}
	return m
}
`
)

type MapCloneItem struct {
	Key          string
	Value        string
	ValueBuildin bool
	FuncName     string
}
type MapClone struct {
	Items []*MapCloneItem
	Gened map[[2]string]bool
}

func newMapClone() *MapClone {
	return &MapClone{
		Gened: make(map[[2]string]bool),
	}
}

func (m *MapClone) add(key, value, funcName string, valueBuildin bool) {
	k := [2]string{key, value}
	if m.Gened[k] {
		return
	}
	m.Gened[k] = true
	m.Items = append(m.Items, &MapCloneItem{
		Key:          key,
		Value:        value,
		ValueBuildin: valueBuildin,
		FuncName:     funcName,
	})
}

type ArrayCloneItem struct {
	Name     string
	FuncName string
	Simple   bool
}

// Generator 生成proto clone代码
type Generator struct {
	pb2         bool
	packageName string

	messages map[string]*parser.Message
	enums    map[string]*parser.Enum
	services map[string]*parser.Service

	mlist          *list.List
	commentMessage []string
	done           map[string]bool
	mapClone       map[string]*MapClone
	arrayClone     map[string]*ArrayCloneItem

	otherPackage map[string][]string

	result *bytes.Buffer
}

// NewGenerator n
func NewGenerator(src []byte) (*Generator, error) {
	file := parser.NewFileInfo()
	p := parser.NewParser(file, src)
	f := p.ParseFile()
	g := &Generator{
		messages:     make(map[string]*parser.Message),
		enums:        make(map[string]*parser.Enum),
		services:     make(map[string]*parser.Service),
		done:         make(map[string]bool),
		mlist:        list.New(),
		arrayClone:   make(map[string]*ArrayCloneItem),
		mapClone:     make(map[string]*MapClone),
		otherPackage: make(map[string][]string),
		result:       bytes.NewBuffer(nil),
	}
	parser.Walk(g, f)

	if g.packageName == "" {
		return nil, fmt.Errorf("[Gen] go_package name not found")
	}

	return g, nil
}

func (g *Generator) Visit(node parser.Node) parser.Visitor {
	switch node := node.(type) {
	case *parser.Syntax:
		g.pb2 = node.Value() == "proto2"
	case *parser.Option:
		if node.Name.Name.(*parser.Ident).Name == "go_package" {
			if n, ok := node.Value.(*parser.String); ok {
				names := strings.Split(n.Value, ";")
				last := names[len(names)-1]
				g.packageName = filepath.Base(last[1 : len(last)-1])
			}
		}
	case *parser.Message:
		var name = node.GetName()
		g.messages[name] = node
	case *parser.Enum:
		name := node.Name.Name
		g.enums[name] = node
	case *parser.Service:
		g.services[node.Name.Name] = node
	}
	return g
}

func (g *Generator) GenAll() []byte {
	for k := range g.messages {
		g.addGen(k)
	}
	return g.genCode()
}

func (g *Generator) GenMessage(messageNames ...string) []byte {
	messageNames = append(messageNames, g.commentMessage...)
	for _, v := range messageNames {
		g.addGen(v)
	}
	return g.genCode()
}

func (g *Generator) getPackageName() string {
	return g.packageName
}

func (g *Generator) P(str ...interface{}) {
	for _, v := range str {
		switch t := v.(type) {
		case string:
			g.result.WriteString(t)
		}
	}
	g.result.WriteByte('\n')
}

func (g *Generator) F(format string, a ...interface{}) {
	fmt.Fprintf(g.result, format, a...)
	g.result.WriteByte('\n')
}

func (g *Generator) genCode() []byte {
	g.result.Reset()
	g.P("// Code generated by gen-protoclone. DO NOT EDIT.")
	g.P("package ", g.getPackageName())
	g.P()

	for g.mlist.Len() > 0 {
		e := g.mlist.Back()
		name := g.mlist.Remove(e).(string)
		if node := g.messages[name]; node != nil {
			g.P(g.genMessage(node))
		} else {
			name := g.convertGoType(name)
			g.F(basePointerClone, strFirstToUpper(name), name, name, name)
		}
	}

	for pname, mapInfo := range g.mapClone {
		for _, item := range mapInfo.Items {
			keyTypeName := g.convertGoType(item.Key)
			var typeName, cloneEx string
			if item.ValueBuildin {
				valueTypeName := g.convertGoType(item.Value)
				typeName = fmt.Sprintf("map[%v]%v", keyTypeName, valueTypeName)
			} else {
				valueTypeName := strFirstToUpper(item.Value)
				if len(pname) > 0 {
					valueTypeName = pname + valueTypeName
				}

				cloneEx = ".Clone()"
				typeName = fmt.Sprintf("map[%v]*%v", keyTypeName, valueTypeName)
			}
			g.F(cloneMap, item.FuncName, typeName, typeName, typeName, cloneEx)
		}
	}

	// 打印数组clone
	for _, item := range g.arrayClone {
		if item.Simple {
			typeName := g.convertGoType(item.Name)
			g.F(baseArrayClone, item.FuncName, typeName, typeName, typeName)
		} else {
			typeName := item.Name
			g.F(structArrayClone, item.FuncName, typeName, typeName, typeName)
		}
	}
	src, err := format.Source(g.result.Bytes())
	if err != nil {
		panic(err)
	}
	return src
}

func (g *Generator) genMessage(m *parser.Message) string {
	buffer := &bytes.Buffer{}
	for j, field := range m.Fields.List {
		if j != 0 {
			buffer.WriteString("\t\t")
		}
		var assign string
		switch node := field.(type) {
		case *parser.Field:
			if node.Label == parser.REPEATED {
				assign = g.genRepeated(m, node)
			} else {
				switch t := node.Type.(type) {
				case *parser.Ident:
					assign = g.genScalar(node.Name, t.Name)
				case *parser.MessageType:
					pname, typeName := g.getMessageTypeName(t)
					assign = g.genSpec(m, node, pname, typeName)
				}
			}
		case *parser.MapField:
			assign = g.genMap(m, node)
		case *parser.Enum, *parser.Message, *parser.Option, *parser.Extensions:
			continue
		case *parser.Oneof:
			panic("oneof not implement")
		default:
			panic("genMessage umimplement")
		}

		buffer.WriteString(assign)
		if j+1 != len(m.Fields.List) {
			buffer.WriteString("\n")
		}
	}
	name := strFirstToUpper(m.GetName())
	return fmt.Sprintf(structClone, name, name, name, buffer.String())
}

func (g *Generator) getMessageTypeName(t *parser.MessageType) (pname, name string) {
	name = t.MessageName.Name
	if t.PeriodPos > 0 {
		pname += parser.PERIOD.String()
	}
	for _, v := range t.Idents {
		pname += v.Name + "."
	}
	if pname == g.getPackageName()+"." {
		pname = ""
	}
	return
}

func (g *Generator) formatName(name string) string {
	name = strFirstToUpper(name)
	var ok bool
	for _, v := range name {
		if v == '_' {
			ok = true
			break
		}
	}
	if !ok {
		return name
	}

	strArry := make([]rune, 0, len(name))
	var upper bool
	for _, v := range name {
		if v == '_' {
			upper = true
		} else {
			if upper && v >= 97 && v <= 122 {
				v -= 32
				upper = false
			}
			strArry = append(strArry, v)
		}
	}
	return string(strArry)
}

func (g *Generator) convertGoType(str string) string {
	switch str {
	case "float":
		return "float32"
	case "double":
		return "float64"
	default:
		return str
	}
}

func (g *Generator) IsProto2() bool {
	return g.pb2
}

func (g *Generator) genScalar(nameNode *parser.Ident, typName string) string {
	goName := g.formatName(nameNode.Name)
	if typName == "bytes" {
		return fmt.Sprintf("%v: append(m.%v[:0:0], m.%v...),", goName, goName, goName)
	}
	if !g.IsProto2() && parser.IsScalar(typName) {
		return fmt.Sprintf("%v: m.Get%v(),", goName, goName)
	}

	g.addGen(typName)
	goType := strFirstToUpper(g.convertGoType(typName))
	return fmt.Sprintf("%v: Clone%vPointer(m.%v),", goName, goType, goName)
}

func (g *Generator) genSpec(m *parser.Message, node *parser.Field, packageName string, typ string) string {
	name := g.formatName(node.Name.Name)
	if g.addOtherPackage(packageName, typ) {
		return fmt.Sprintf("%v: m.Get%v().Clone(),", name, name)
	}
	if inMsg := m.FindNestedMessage(typ); inMsg != nil {
		g.addGen(inMsg.GetName())
	} else if _, ok := g.enums[typ]; ok { // enum
		if g.IsProto2() {
			return fmt.Sprintf("%v: m.Get%v().Enum(),", name, name)
		}
		return fmt.Sprintf("%v: m.Get%v(),", name, name)
	} else {
		g.addGen(typ)
	}
	return fmt.Sprintf("%v: m.Get%v().Clone(),", name, name)
}

func (g *Generator) genRepeated(m *parser.Message, node *parser.Field) string {
	switch t := node.Type.(type) {
	case *parser.Ident:
		typeName := t.Name
		goType := strFirstToUpper(g.convertGoType(typeName))
		goName := strFirstToUpper(node.Name.Name)
		g.addArrayClone(typeName, true, goType)
		return fmt.Sprintf(cloneLineArray, goName, goType, goName)
	case *parser.MessageType:
		goName := strFirstToUpper(node.Name.Name)
		pname, typeName := g.getMessageTypeName(t)
		if pname != "" {
			g.addOtherPackage(pname, typeName)
			goType := strFirstToUpper(typeName)
			funcName := strFirstToUpper(strings.ReplaceAll(pname, ".", "_")) + goType
			g.addArrayClone(pname+typeName, false, funcName)
			return fmt.Sprintf("%v: Clone%vArray(m.Get%v()),", goName, funcName, goName)
		}
		if nestedMessage := m.FindNestedMessage(typeName); nestedMessage != nil {
			g.addGen(nestedMessage.GetName())
			goType := strFirstToUpper(typeName)
			g.addArrayClone(typeName, false, goType)
			return fmt.Sprintf(cloneLineArray, goName, goType, goName)
		}
		if _, ok := g.messages[typeName]; ok {
			g.addGen(typeName)
			goType := strFirstToUpper(typeName)
			g.addArrayClone(typeName, false, goType)
			return fmt.Sprintf(cloneLineArray, goName, goType, goName)
		} else if _, ok := g.enums[typeName]; ok {
			goType := typeName
			g.addArrayClone(typeName, true, goType)
			return fmt.Sprintf(cloneLineArray, goName, goType, goName)
		}
	}
	panic("genRepeated not implement")
}

func (g *Generator) genMap(m *parser.Message, mf *parser.MapField) string {
	var funcName string
	keyType := g.convertGoType(mf.KeyType.Name)
	switch t := mf.ValueType.(type) {
	case *parser.Ident:
		valueType := g.convertGoType(t.Name)
		funcName = strFirstToUpper(keyType) + strFirstToUpper(valueType)
		g.addMapClone(keyType, valueType, "", funcName, true)
	case *parser.MessageType:
		pname, valueType := g.getMessageTypeName(t)
		if g.addOtherPackage(pname, valueType) {
			funcName = strFirstToUpper(keyType) + strFirstToUpper(strings.ReplaceAll(pname, ".", "_")) + strFirstToUpper(valueType)
			g.addMapClone(keyType, valueType, pname, funcName, false)
		} else {
			for t := m; t != nil; t = t.Parent {
				if m := t.FindNestedMessage(valueType); m != nil {
					valueType = m.GetName()
					break
				}
			}
			funcName = strFirstToUpper(keyType) + strFirstToUpper(valueType)
			g.addGen(valueType)
			g.addMapClone(keyType, valueType, "", funcName, false)
		}
	}
	goName := g.formatName(mf.Name.Name)
	return fmt.Sprintf("%v: Clone%vMap(m.Get%v()),", goName, funcName, goName)
}

func (g *Generator) addMapClone(keyType, valueType, packageName, funcName string, valueBuildin bool) {
	if packageName == g.getPackageName() {
		packageName = ""
	}
	c := g.mapClone[packageName]
	if c == nil {
		c = newMapClone()
		g.mapClone[packageName] = c
	}
	c.add(keyType, valueType, funcName, valueBuildin)
}

func (g *Generator) addOtherPackage(pname, rawType string) bool {
	if pname != "" && pname != g.getPackageName() {
		for _, v := range g.otherPackage[pname] {
			if v == rawType {
				return true
			}
		}
		g.otherPackage[pname] = append(g.otherPackage[pname], rawType)
		return true
	}
	return false
}

func (g *Generator) addArrayClone(name string, simple bool, funcName string) {
	if _, ok := g.arrayClone[name]; ok {
		return
	}
	g.arrayClone[name] = &ArrayCloneItem{
		Name:     name,
		FuncName: funcName,
		Simple:   simple,
	}
}

func (g *Generator) addGen(name string) {
	if name != "" && !g.done[name] {
		g.done[name] = true
		g.mlist.PushBack(name)
	}
}

func strFirstToUpper(str string) string {
	if len(str) == 0 || str[0] >= 65 && str[0] <= 90 {
		return str
	}
	strArray := []rune(str)
	if strArray[0] >= 97 && strArray[0] <= 122 {
		strArray[0] -= 32
	}
	return string(strArray)
}

type GenResult struct {
	Src          []byte
	OtherPackage map[string][]string
}

// Gen 生成
func Gen(src []byte, messageName []string) (*GenResult, error) {
	generator, err := NewGenerator(src)
	if err != nil {
		return nil, err
	}
	res := generator.GenMessage(messageName...)
	return &GenResult{
		Src:          res,
		OtherPackage: generator.otherPackage,
	}, nil
}

func GenAll(src []byte) (*GenResult, error) {
	generator, err := NewGenerator(src)
	if err != nil {
		return nil, err
	}
	res := generator.GenAll()
	return &GenResult{
		Src:          res,
		OtherPackage: generator.otherPackage,
	}, nil
}
